# Missing: explanatory messages for error scenarios:
# -> cannot run backup (drive not mounted, other)
# -> cannot run and we are really late (overdue)
# -> mount failed
# -> rsync failed
# -> rsync success

# Missing FUNCTIONS
# rsync

import sys
import os
import ConfigParser
import logging
import logging.handlers
import datetime
import subprocess

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

RSYNC_OPTIONS_DEFAULT = "--stats --dry-run --del --relative -a"
RSYNC_LOGDIR_DEFAULT = "/var/log/my_backup.log"
DEFAULT_CFG_FILE = ".my_backup.cfg"

CHECK_DEV_MOUNTED = "check_dev_mounted.sh"
UMOUNT_DEV = "umount_dev.sh"
MOUNT_DEV = "mount_dev.sh"
RUN_RSYNC = "run_rsync.sh"

OVERDUE_THRESHOLD_DAYS_DEFAULT = 7
RETRY_DAYS_DEFAULT = 2
RETRY_WHEN_OVERDUE_DAYS_DEFAULT = 1
BACKUP_INTERVAL_DAYS_DEFAULT = 14

logger = None

MY_INFO = 0
MY_WARN = 1
MY_ERROR = 2

SUCCESS = True
NO_SUCCESS = False

__version__ = 0.1
__date__ = '2013-02-18'
__updated__ = '2014-08-22'

class BackupNotPossibleError(Exception):
    pass

class ConfigError(Exception):
    pass

class MyConfig:
    overdue_threshold_days = None
    retry_days = None
    retry_when_overdue_days = None
    backup_interval_days = None
    config = None
    pidfile = None
    cfg_file = None
    cfg_file_obj = None
    dev = None
    email_mailhost = None
    email_fromaddr = None
    email_toaddrs = None
    email_subject = None
    email_subject = None
    email_user = None
    email_pass = None

def runDir():
    return os.path.dirname(os.path.realpath(sys.argv[0]))+"/"

def cleanup(myConfig):

    mounted = None
    # if myConfig.dev there's no way we could have mounted dev ourselves
    if myConfig.dev:
        try:
            mounted = check_dev_mounted(myConfig.dev)
        except Exception as e:
            logging.error("Unable to determine if target device is still mounted: %s" % e.message)

    if mounted:
            logging.debug("%s is mounted, umounting it" % str(myConfig.dev).rstrip())
            try:
                umount_dev(myConfig.dev)
            except Exception as e:
                logging.error("Unable to unmount target device: %s" % e.message)

    cfg_file_obj = open(str(myConfig.cfg_file).strip(),'w')
    myConfig.config.write(cfg_file_obj)
    cfg_file_obj.close()
    os.unlink(myConfig.pidfile)

def exit_early(msg, myConfig, sev):

    today = datetime.date.today()

    if not myConfig.config.has_section('Autogenerated'):
        myConfig.config.add_section('Autogenerated')

    try:
        last_success_string = myConfig.config.get('Autogenerated', 'last_success')
        last_success = datetime.datetime.strptime(last_success_string, '%Y-%m-%d').date()
    except:
        last_success = datetime.date(1970,1,1)

    interval = datetime.timedelta(myConfig.backup_interval_days)
    threshold = datetime.timedelta(myConfig.overdue_threshold_days)
    if today > (last_success + interval + threshold):
        sev = MY_WARN
        next_action = today + datetime.timedelta(days=myConfig.retry_when_overdue_days)
        suffix = "Exiting early, but !BACKUP IS OVERDUE!, will check again in " \
        + str(myConfig.retry_when_overdue_days) + " day(s) (" + str(next_action) + ")"
    else:
        next_action = today + datetime.timedelta(days=myConfig.retry_days)
        suffix = "Exiting early, will check again in " + str(myConfig.retry_days) \
        + " day(s) (" + str(next_action) + ")"

    try:
        myConfig.config.set('Autogenerated', 'next_action', str(next_action))
    except:
        logging.error("Unable to update config file with new dates upon early exit")

    if sev == MY_INFO:
        logging.info("%s %s" % (msg, suffix))
    elif sev == MY_WARN:
        logging.warn("%s %s" % (msg, suffix))
    elif sev == MY_ERROR:
        logging.error("%s %s" % (msg, suffix))

    cfg_file_obj = open(str(myConfig.cfg_file).strip(),'w')
    myConfig.config.write(cfg_file_obj)
    cfg_file_obj.close()

    cleanup(myConfig)

    if sev == MY_INFO:
        exit(1)
    elif sev == MY_WARN:
        exit(2)
    elif sev == MY_ERROR:
        exit(3)

def exit_success(msg, myConfig):

    today = datetime.date.today()

    if not myConfig.config.has_section('Autogenerated'):
        myConfig.config.add_section('Autogenerated')

    next_action_days = myConfig.backup_interval_days
    next_action = today + datetime.timedelta(days=next_action_days)
    try:
        myConfig.config.set('Autogenerated', 'last_success', str(today))
        myConfig.config.set('Autogenerated', 'next_action', str(next_action))
    except:
        logging.error("Unable to update config file with new dates after successful completion")

    email_mailhost = myConfig.email_mailhost
    email_fromaddr = myConfig.email_fromaddr
    email_toaddrs = myConfig.email_toaddrs
    email_subject = myConfig.email_subject_success
    email_user = myConfig.email_user
    email_pass = myConfig.email_pass

    if email_mailhost and email_fromaddr and email_toaddrs and email_subject:
        mail_handler = logging.handlers.SMTPHandler(email_mailhost,
                email_fromaddr, email_toaddrs, email_subject,
                credentials=(email_user,email_pass), secure=())
        mail_handler.setLevel(logging.INFO)
        success_logger = logging.getLogger('success_logger')
        success_logger.addHandler(mail_handler)

    cleanup(myConfig)

    success_logger.info("Backup completed sucessfully.\n\n" \
            "::::::::::::::rsync output::::::::::::::\n%s\n" \
            "::::::::::::::::::::::::::::::::::::::::\n\n" \
            "Next backup is due on %s" % (msg, str(next_action)))

    exit(0)

def check_srcs_present(srcpaths):
        logging.debug("checking for source paths: %s", str(srcpaths))
        # keep original list as is for comparing completeness
        srcpaths2 = list(srcpaths)
        # iterate over copy of list only, removing from actual list doesn't work
	for path in list(srcpaths2):
		if not os.path.exists(path):
			logging.debug("%s does not exist, removing it from the list of sources" % path)
			srcpaths2.remove(path)
	return srcpaths2

def get_dev_for_uuid(uuid):
	uuids = []
	proc = subprocess.Popen(["ls", "-1", "/dev/disk/by-uuid"], stdout=subprocess.PIPE)
	while True:
		line = proc.stdout.readline()
		if line != '':
			uuids.append(line.rstrip())
		else:
			break

        logging.debug("Determining block device for UUID %s ... " % str(uuid))
	if uuid[0] in uuids:
		#TODO: more error checking
		proc = subprocess.Popen(["blkid", "-U", str(uuid[0])], stdout=subprocess.PIPE)
		#TODO: more error checking
		dev = proc.stdout.readline()
		logging.debug("Found %s" % str(dev).rstrip())
	else:
		raise BackupNotPossibleError('UUID %s could not be found' % str(uuid))
	return  dev


# fiddling with mount points in python is quite tedious, hence we use three helper shell scripts

#returns True if uuid is mounted, False otherwise
def check_dev_mounted(dev):
        try:
            proc = subprocess.Popen([runDir()+CHECK_DEV_MOUNTED, dev],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = proc.communicate()
        except:
            raise
	if proc.returncode > 0:
            return False
	else:
            return True


def umount_dev(dev):
        try:
            proc = subprocess.Popen([runDir()+UMOUNT_DEV, dev],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = proc.communicate()
        except:
            raise
	if proc.returncode > 0:
            raise BackupNotPossibleError("%s return code: %s. STDOUT: \"%s\" STDERR: \"%s\"" %
                    (str(UMOUNT_DEV), str(proc.returncode), str(out), str(err).rstrip()))
	else:
		return True

def mount_dev(dev, trgt):
        try:
            proc = subprocess.Popen([runDir()+MOUNT_DEV, dev, trgt],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = proc.communicate()
        except:
            raise
	if proc.returncode > 0:
            raise BackupNotPossibleError("%s return code: %s. STDOUT: \"%s\" STDERR: \"%s\"" %
                    (str(MOUNT_DEV), str(proc.returncode), str(out), str(err).rstrip()))
	else:
		return True


def main(argv=None): # IGNORE:C0111
    '''Command line options.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)

    myConfig = MyConfig()

    try:
        # Setup argument parser
        parser = ArgumentParser(formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbosity", dest="verbosity",
                help="set verbosity level (debug|info|warning|error), default: warning")
        parser.add_argument("-c", "--cfg-file", dest="cfg_file",
                help="path to config file (default: my_backup.conf")
        parser.add_argument("-u", "--dst_uuid", dest="dst_uuid",
                help="UUID of the backup disk")
        parser.add_argument("-d", "--dst_path", dest="dst_path",
                help="Additional path on backup disk")
        parser.add_argument("-m", "--dst_mount", dest="dst_mount",
                help="mount point for backup disk")
        parser.add_argument("-o", "--rsync_options", dest="rsync_options",
                help="Options to pass to rsync command")
        parser.add_argument("-l", "--rsync_logdir", dest="rsync_logdir",
                help="rsync logdir")
        parser.add_argument('-V', '--version', action='version',
                version=program_version_message)
        parser.add_argument(dest="srcpaths",
                help="srcpaths to source folders (overrides config file)", nargs='*')

        # Process arguments
        args = parser.parse_args()

        log_file = None
        email_mailhost = None
        email_fromaddr = None
        email_toaddrs = None
        email_subject = None
        email_user = None

        myConfig = MyConfig()
        email_pass = None
        verbosity = args.verbosity
        cfg_file = args.cfg_file
        srcpaths = args.srcpaths
        dst_uuid = args.dst_uuid
	dst_mount = args.dst_mount
        dst_path = args.dst_path
        rsync_options = args.rsync_options
        rsync_logdir = args.rsync_logdir



        if not cfg_file:
            cfg_file = os.path.join(os.path.abspath(os.curdir), DEFAULT_CFG_FILE)
        if not os.path.exists(cfg_file):
            open(cfg_file, 'a+').close()

        config = ConfigParser.ConfigParser()
        config.read(cfg_file)
        if not config.has_section('General'):
            config.add_section('General')

        myConfig.config = config
        myConfig.cfg_file = cfg_file


        #-------------------- set up the logger ---------------#


        #TODO: Add log_file to command line parms
        if not log_file and config:
            try:
                log_file = config.get('General', 'log_file').split()
            except:
                pass

        LEVELS = {'debug': logging.DEBUG,
          'info': logging.INFO,
          'warning': logging.WARNING,
          'error': logging.ERROR,
          'critical': logging.CRITICAL}

        if not verbosity and config:
            verbosity = config.get('General', 'verbosity')
        log_level = LEVELS.get(verbosity, logging.WARNING)

        logging.basicConfig(level=log_level,
                            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                            datefmt='%m-%d %H:%M')

        cons_handler = logging.StreamHandler()
        cons_handler.setLevel(logging.INFO)
        #logging.getLogger('').addHandler(cons_handler)

        #TODO: not tested yet
        if log_file:
            file_handler = logging.FileHandler(log_file, mode='a')
            file_handler.setLevel(logging.DEBUG)
            logging.getLogger('').addHandler(file_handler)

        syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
        syslog_handler.setLevel(logging.WARNING)
        logging.getLogger('').addHandler(syslog_handler)


        #-------------------- End of set up the logger ---------------#

        pid = str(os.getpid())
        pidfile = "/tmp/my_backup.pid"
        myConfig.pidfile = pidfile

        if os.path.isfile(pidfile):
            logging.info("%s already exists, exiting" % pidfile)
            sys.exit()
        else:
            file(pidfile, 'w').write(pid)

        logging.debug("log_file = %s" % str(log_file))
        logging.debug("pidfile = %s" % str(pidfile))

        #------------------------ config parsing ----------------------------#

        # mail handler comes here should only be invoked for non-success messages
        try:
            myConfig.email_mailhost = str(config.get('General', 'email_mailhost'))
            myConfig.email_fromaddr = str(config.get('General', 'email_fromaddr'))
            myConfig.email_toaddrs = str(config.get('General', 'email_toaddrs'))
            myConfig.email_subject_early_exit = str(config.get('General', 'email_subject_early_exit'))
            myConfig.email_subject_success = str(config.get('General', 'email_subject_success'))
            myConfig.email_user = str(config.get('General', 'email_user'))
            myConfig.email_pass = str(config.get('General', 'email_pass'))

            email_mailhost = myConfig.email_mailhost
            email_fromaddr = myConfig.email_fromaddr
            email_toaddrs = myConfig.email_toaddrs
            email_subject = myConfig.email_subject_early_exit
            email_user = myConfig.email_user
            email_pass = myConfig.email_pass

            if email_mailhost and email_fromaddr and email_toaddrs and email_subject:
                mail_handler = logging.handlers.SMTPHandler(email_mailhost,
                        email_fromaddr, email_toaddrs, email_subject,
                        credentials=(email_user,email_pass), secure=())
                mail_handler.setLevel(logging.WARNING)
                logging.getLogger('').addHandler(mail_handler)

        except Exception as e:
            logging.warning("Unable to get email config for my_backup: %s", e.message)
            pass

        if not myConfig.backup_interval_days and config:
            try:
                myConfig.backup_interval_days = int(config.get('General',
                    'backup_interval_days'))
            except Exception:
                myConfig.backup_interval_days = BACKUP_INTERVAL_DAYS_DEFAULT

        if not myConfig.retry_days and config:
            try:
                myConfig.retry_days = int(config.get('General', 'retry_days'))
            except Exception:
                myConfig.retry_days = RETRY_DAYS_DEFAULT

        if not myConfig.overdue_threshold_days and config:
            try:
                myConfig.overdue_threshold_days = int(config.get('General',
                    'overdue_threshold_days'))
            except Exception:
                myConfig.overdue_threshold_days = OVERDUE_THRESHOLD_DAYS_DEFAULT

        if not myConfig.retry_when_overdue_days and config:
            try:
                myConfig.retry_when_overdue_days = int(config.get('General',
                    'retry_when_overdue_days'))
            except Exception:
                myConfig.retry_when_overdue_days = RETRY_WHEN_OVERDUE_DAYS_DEFAULT

	today = datetime.date.today()
        try:
            next_action_string = config.get('Autogenerated', 'next_action')
            next_action = datetime.datetime.strptime(next_action_string, '%Y-%m-%d').date()
        except Exception:
            next_action = today-datetime.timedelta(days=1)


	if today < next_action:
            # We are not calling exit_early here, since it updates next_action in cfg_file
            logging.info("Backup is not due today, will be due on %s" % str(next_action))
            cleanup(myConfig)
            sys.exit(0)
	else:
            logging.info("Backup is due")

        if not srcpaths and config:
            try:
                srcpaths = config.get('General', 'srcpaths').split()
            except:
                pass
        # one might think that 'not srcpaths' could be handled in the exception,
        # but the code may have run exceptionless and still yield an empty string
        # if the exception does occur otoh, srcpaths are not
        if srcpaths:
            logging.debug("Source paths = " + str(srcpaths))
        else:
            exit_early("Source paths are not defined."
                "Pass them on the command line on in the configuration file.",
                    myConfig, MY_WARN)

        if not dst_mount and config:
            try:
                dst_mount = config.get('General', 'dst_mount').split()
            except:
                pass
        # see comment above on srcpaths
        if not dst_mount:
            exit_early("Destination mount point not defined."
                    "Pass it on the command line or in the configuration file.",
                    myConfig, MY_WARN)

        if not dst_uuid and config:
            try:
                dst_uuid = config.get('General', 'dst_uuid').split()
            except:
                pass
        # see comment above on srcpaths
        if not dst_uuid:
            exit_early("Destination UUID not defined"
                "Pass it on the command line on in the configuration file.",
                myConfig, MY_WARN)

        # Destination path is completely optional
        if not dst_path and config:
            try:
                dst_path = config.get('General', 'dst_path').split()
            # Maybe the user didn't supply it
            # There's also the remote chance that he did and then there
            # was an error reading it, but that seems unlikely
            except:
                pass

        if not rsync_options and config:
            try:
                rsync_options = config.get('General', 'rsync_options').split()
            except:
                pass
        # see comment above on srcpaths
        if not rsync_options:
            rsync_options = RSYNC_OPTIONS_DEFAULT

        if not rsync_logdir and config:
            try:
                rsync_logdir = config.get('General', 'rsync_logdir').split()
            except:
                pass
        if not rsync_logdir:
            rsync_logdir = RSYNC_LOGDIR_DEFAULT

        #------------------------ END OF config parsing ----------------------------#

	present_srcpaths = check_srcs_present(srcpaths)
        #Initially I thought, if not all srcpaths can be found just
        #run with the ones to be found, but with destructive backups
        # the absence of a path may mean we delete the backup too!
        if set(present_srcpaths) != set(srcpaths):
            exit_early("Not all srcspaths can be found.", myConfig, MY_WARN)

        try:
            dev = get_dev_for_uuid(dst_uuid)
        except Exception as e:
            exit_early(e.message, myConfig, MY_WARN)
        myConfig.dev = dev

        try:
            mounted = check_dev_mounted(dev)
        except Exception as e:
            exit_early(e.message, myConfig, MY_WARN)

        if mounted:
                logging.debug("%s is mounted, umounting it" % (dst_uuid))
                try:
                    umount_dev(dev)
                except Exception as e:
                    exit_early("Error unmounting %s (%s)" % (str(dst_uuid), str(e.message)),
                            myConfig, MY_WARN)

        logging.info("Mounting %s to %s" % (dst_uuid, dst_mount))
        try:
            mount_dev(dev, ''.join(dst_mount))
        except Exception as e:
            exit_early("Error mounting %s (%s)" % (dst_uuid, e.message), myConfig, MY_WARN)

	# We made it to this point, disk is properly mounted, now check target path exists
	dst = ''.join((dst_mount + dst_path))
	if not os.path.exists(dst):
                exit_early("Target path %s on device %s cannot be found." % (dst, str(dev).rstrip()),
                        myConfig, MY_WARN)

	# we made it here:
	# src paths all exist, device mounted, target path exists
        logging.info("running rsync command now...")
        sources_string = " ".join(present_srcpaths)
        all_options_string = " ".join([rsync_options, sources_string, dst])
        out = None
        logging.debug("calling rsync as: rsync %s" % all_options_string)
        try:
            proc = subprocess.Popen([runDir()+RUN_RSYNC, all_options_string],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = proc.communicate()
        except Exception as e:
            exit_early("Unexpected error during rsync command: (%s)" % (e.message),
                    myConfig, MY_ERROR)

	if proc.returncode > 0:
            exit_early("rsync command failed: %s return code: %s. STDOUT: \"%s\" STDERR: \"%s\"" %
                    (str(UMOUNT_DEV), str(proc.returncode), str(out), str(err).rstrip()),
                    myConfig, MY_ERROR)
	else:
            exit_success(out, myConfig)


    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0


if __name__ == "__main__":
    sys.exit(main())

