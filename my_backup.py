# Missing: explanatory messages for error scenarios:
# -> cannot run backup (drive not mounted, other)
# -> cannot run and we are really late (overdue)
# -> mount failed
# -> rsync failed
# -> rsync success

# Missing FUNCTIONS
# email
# syslog / wall
# error (using email and syslog)
# warning (dto.)
# info (dto.)
# rsync

import sys
import os
import ConfigParser
import logging
import logging.handlers
import datetime
import subprocess

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

# create pid_file


# Compare if last backup is past longer than intervall
# if yes try to backup, but run checks first
#	has the drive been mounted automatically already?
#		if yes, umount, mount again under uuid, success?
#	is drive there?
#	do all directories (src/dest) exist	?
#	if any errors exit and advance due time just 2 days (or configurable)
#
# if no, see if we are 3 days close to it
# if 3 days close to it, give heads up via mail
# if not 3 days close to it, just echo that no backup is needed until...

# delete pidfile
RSYNC_OPTIONS_DEFAULT = "--stats --del -rt"
RSYNC_LOGDIR_DEFAULT = "/var/log/my_backup.log"
DEFAULT_CFG_FILE = "~/.my_backup.cfg"

CHECK_DEV_MOUNTED = "./check_dev_mounted.sh"
UMOUNT_DEV = "./umount_dev.sh"
MOUNT_DEV = "./mount_dev.sh"

cfg_file = None
srcpaths = None
dst_uuid = None
dst_mount = None
dst_path = None
rsync_options = None
rsync_logdir = None
config = None
pidfile = None
retry_days = None
backup_interval_days = None
cfg_file_obj = None
verbose = None
logger = None

DEBUG = 0
TESTRUN = 0
PROFILE = 0

__version__ = 0.1
__date__ = '2013-02-18'
__updated__ = '2014-08-22'

class BackupNotPossibleError(Exception):
    pass

class ConfigError(Exception):
    pass


def check_srcs_present(srcpaths):
        logging.debug("checking for source paths: %s", str(srcpaths))
	for path in srcpaths:
                #TODO BUG?: ~/test ~/test2 both not existing, only ~/test is removed?
		if not os.path.exists(path):
			logging.debug("%s does not exist, removing it from the list of sources" % path)
			srcpaths.remove(path)
			continue;
	return srcpaths

def exit_with_grace(msg):
    global config
    global pidfile
    global retry_days
    global cfg_file
    global cfg_file_obj
    next_action = datetime.date.today()+datetime.timedelta(days=retry_days)
    logging.warn("%s. Exiting program, will check again in %s days (%s)" %
            (msg, str(retry_days), str(next_action)))
    config.set('Autogenerated', 'next_action', str(next_action))
    cfg_file_obj = open(str(cfg_file).strip(),'w')
    config.write(cfg_file_obj)
    cfg_file_obj.close()
    #TODO: Start using the pidfile
    #os.unlink(pidfile)
    sys.exit(0)

def exit_with_error(msg):
    global config
    global pidfile
    global retry_days
    global cfg_file
    global cfg_file_obj
    next_action = datetime.date.today()+datetime.timedelta(days=1)
    logging.error("An error occured: %s. Exiting program, will check again tomorrow" %
            (str(retry_days), str(next_action)))
    config.set('Autogenerated', 'next_action', str(next_action))
    cfg_file_obj = open(str(cfg_file).strip(),'w')
    config.write(cfg_file_obj)
    cfg_file_obj.close()
    #TODO: Start using the pidfile
    #os.unlink(pidfile)
    sys.exit(1)

def exit_backup_not_possible(msg):
    exit_with_grace(msg)

def exit_config_error(msg):
    exit_gracefully(msg)

def get_dev_for_uuid(uuid):
	uuids = []
	proc = subprocess.Popen(["ls", "-1", "/dev/disk/by-uuid"], stdout=subprocess.PIPE)
	while True:
		line = proc.stdout.readline()
		if line != '':
			uuids.append(line.rstrip())
		else:
			break

        logging.debug("Determining block device for UUID %s ... " % str(uuid))
	if uuid[0] in uuids:
		#TODO: more error checking
		proc = subprocess.Popen(["blkid", "-U", str(uuid[0])], stdout=subprocess.PIPE)
		#TODO: more error checking
		dev = proc.stdout.readline()
		logging.debug("Found %s" % (dev, str(uuid[0])))
	else:
		raise BackupNotPossibleError('UUID %s could not be found' % str(uuid))
	return  dev


# fiddling with mount points in python is quite tedious, hence we use three helper shell scripts

#returns True if uuid is mounted, False otherwise
def check_dev_mounted(dev):
	proc = subprocess.Popen([CHECK_DEV_MOUNTED, dev], stdout=subprocess.PIPE)
	proc.wait()
	if proc.returncode > 0:
            raise BackupNotPossibleError("%s returned with %s" % CHECK_DEV_MOUNTED, proc.returncode)
	else:
		return True


def umount_dev(dev):
	proc = subprocess.Popen([UMOUNT_DEV, dev], stdout=subprocess.PIPE)
	proc.wait()
        if not proc.returncode:
            raise BackupNotPossibleError("%s returned with %s" % UMOUNT_DEV, proc.returncode)
        else:
            return proc.returncode

def mount_dev(dev, trgt):
	proc = subprocess.Popen([MOUNT_DEV, dev, trgt], stdout=subprocess.PIPE)
	proc.wait()
        if not proc.returncode:
            raise BackupNotPossibleError("%s returned with %s" % MOUNT_DEV, proc.returncode)
        else:
            return proc.returncode

def check_trgt_present(trgt):
	#TODO: assuming we get a UUID, but ultimately parse or customize
	# target type via different command line params
	trgt = check_trgt_UUID(trgt)
	return trgt



def main(argv=None): # IGNORE:C0111
    '''Command line options.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)

    global config
    global retry_days
    global cfg_file_obj
    global cfg_file
    global verbose


    try:
        # Setup argument parser
        parser = ArgumentParser(formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbosity", dest="verbosity",
                help="set verbosity level (debug|info|warning|error), default: warning")
        parser.add_argument("-c", "--cfg_file", dest="cfg_file",
                help="path to config file (default: my_backup.conf")
        parser.add_argument("-u", "--dst_uuid", dest="dst_uuid",
                help="UUID of the backup disk")
        parser.add_argument("-d", "--dst_path", dest="dst_path",
                help="Additional path on backup disk")
        parser.add_argument("-m", "--dst_mount", dest="dst_mount",
                help="mount point for backup disk")
        parser.add_argument("-o", "--rsync_options", dest="rsync_options",
                help="Options to pass to rsync command")
        parser.add_argument("-l", "--rsync_logdir", dest="rsync_logdir",
                help="rsync logdir")
        parser.add_argument('-V', '--version', action='version',
                version=program_version_message)
        parser.add_argument(dest="srcpaths",
                help="srcpaths to source folders (overrides config file)", nargs='*')

        # Process arguments
        args = parser.parse_args()

        log_file = None
        email_mailhost = None
        email_fromaddr = None
        email_toaddrs = None
        email_subject = None
        email_user = None
        email_pass = None
        verbosity = args.verbosity
        cfg_file = args.cfg_file
        srcpaths = args.srcpaths
        dst_uuid = args.dst_uuid
	dst_mount = args.dst_mount
        dst_path = args.dst_path
        rsync_options = args.rsync_options
        rsync_logdir = args.rsync_logdir

        pid = str(os.getpid())
        pidfile = "/tmp/mydaemon.pid"

        #if os.path.isfile(pidfile):
        #    print "%s already exists, exiting" % pidfile
        #    sys.exit()
        #else:
        #    file(pidfile, 'w').write(pid)


        if cfg_file:
            config = ConfigParser.ConfigParser()
            config.read(cfg_file)
        else:
            cfg_file = DEFAULT_CFG_FILE
            config = None

        #------------------------ config parsing ----------------------------#

        #-------------------- set up the logger ---------------#


        #TODO: Add log_file to command line parms
        if not log_file and config:
            log_file = config.get('General', 'log_file').split()

        LEVELS = {'debug': logging.DEBUG,
          'info': logging.INFO,
          'warning': logging.WARNING,
          'error': logging.ERROR,
          'critical': logging.CRITICAL}

        if not verbosity and config:
            verbosity = config.get('General', 'verbosity')
        log_level = LEVELS.get(verbosity, logging.WARNING)

        if not email_mailhost and config:
            email_mailhost = str(config.get('General', 'email_mailhost'))
        if not email_fromaddr and config:
            email_fromaddr = str(config.get('General', 'email_fromaddr'))
        if not email_toaddrs and config:
            email_toaddrs = str(config.get('General', 'email_toaddrs'))
        if not email_subject and config:
            email_subject = str(config.get('General', 'email_subject'))
        if not email_user and config:
            email_user = str(config.get('General', 'email_user'))
        if not email_pass and config:
            email_pass = str(config.get('General', 'email_pass'))

        logging.basicConfig(level=log_level,
                            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                            datefmt='%m-%d %H:%M')

        cons_handler = logging.StreamHandler()
        cons_handler.setLevel(logging.INFO)
        #logging.getLogger('').addHandler(cons_handler)

        if log_file:
            file_handler = logging.FileHandler(log_file, mode='a')
            file_handler.setLevel(logging.DEBUG)
            logging.getLogger('').addHandler(file_handler)

        syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
        syslog_handler.setLevel(logging.WARNING)
        logging.getLogger('').addHandler(syslog_handler)

        if email_mailhost and email_fromaddr and email_toaddrs and email_subject:
            mail_handler = logging.handlers.SMTPHandler(email_mailhost,
                    email_fromaddr, email_toaddrs, email_subject,
                    credentials=(email_user,email_pass), secure=())
            mail_handler.setLevel(logging.WARNING)
            logging.getLogger('').addHandler(mail_handler)

        #-------------------- End of set up the logger ---------------#

        logging.debug("log_file = %s" % str(log_file))

        next_action_string = config.get('Autogenerated', 'next_action')
	backup_interval_days = int(config.get('General', 'backup_interval_days'))
        retry_days = int(config.get('General', 'retry_days'))

        try:
            next_action = datetime.datetime.strptime(next_action_string, '%Y-%m-%d').date()
        except ValueError:
            next_action = datetime.date.today()-datetime.timedelta(days=1)

	today = datetime.date.today()

	if today < next_action:
		exit_with_grace("Backup is not due today, will be due on %s" % str(next_action))
	else:
		logging.info("Backup is due")

        if not srcpaths and config:
            srcpaths = config.get('General', 'srcpaths').split()
        if srcpaths:
            logging.debug("Source paths = " + str(srcpaths))
        else:
            exit_with_grace("Source paths are not defined."
                "Pass them on the command line on in the configuration file.")

        if not dst_mount and config:
            dst_mount = config.get('General', 'dst_mount').split()
        if not dst_mount:
            exit_with_grace("Destination mount point not defined."
                "Pass it on the command line or in the configuration file.")

        if not dst_uuid and config:
            dst_uuid = config.get('General', 'dst_uuid').split()
        if not dst_uuid:
            exit_with_grace("Destination UUID not defined"
                "Pass it on the command line on in the configuration file.")

        # Destination path is completely optional
        if not dst_path and config:
            dst_path = config.get('General', 'dst_path').split()

        if not rsync_options and config:
            rsync_options = config.get('General', 'rsync_options').split()
        if not rsync_options:
            rsync_options = RSYNC_OPTIONS_DEFAULT

        if not rsync_logdir and config:
            rsync_logdir = config.get('General', 'rsync_logdir').split()
        if not rsync_logdir:
            rsync_logdir = RSYNC_LOGDIR_DEFAULT

        #------------------------ END OF config parsing ----------------------------#

	srcspaths = check_srcs_present(srcpaths)
	for path in srcpaths:
		logging.debug("source path(s):" + str(path))

        try:
            dev = get_dev_for_uuid(dst_uuid)
        except BackupNotPossibleError as e:
            exit_backup_not_possible(e.message)

        loggin.info("Found %s for UUID %s" % (dev, dst_uuid))

        try:
            mounted = check_dev_mounted(dev)
        except BackupNotPossibleError as e:
            exit_backup_not_possible(e.message)

        if mounted:
                logging.debug("%s is mounted, umounting it" % (dst_uuid))
                try:
                    umount_dev(dev)
                except BackupNotPossibleError:
                    exit_backup_not_possible("Error unmounting %s (%s)" % (dst_uuid, e.message))
                else:
                        logging.debug("Mounting %s again to %s" % (dst_uuid, dst_path))
        else:
                logging.info("%s is not mounted, mounting it to %s" % (dst_uuid, dst_mount))
                try:
                    mount_dev(dev, ''.join(dst_mount))
                except BackupNotPossibleError as e:
                    exit_backup_not_possible("Error mounting %s (%s)" % (dst_uuid, e.message))

	# we made it to this point, disk is properly mounted, now check target path exists
	dst = ''.join((dst_mount + dst_path))
	if not os.path.exists(dst):
                exit_backup_not_possible("Target path %s on device %s cannot be found" % (dst, dev))

	# we made it here:
	# src paths all exist, device mounted, target path exists
        print("_________Ready to execute rsync______")




	# if success:
        # run_backup
        # if backup fails
	# next_date_to_act = config.set('Autogenerated', 'next_action', _today+retry_days_)
#if backup successfull
	# next_date_to_act = config.set('Autogenerated', 'next_action', _today+backup_interval_days_)



    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0


if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-v")
    sys.exit(main())

