# Missing: explanatory messages for error scenarios:
# -> cannot run backup (drive not mounted, other)
# -> cannot run and we are really late (overdue)
# -> mount failed
# -> rsync failed
# -> rsync success

# Missing FUNCTIONS
# email
# syslog / wall
# error (using email and syslog)
# warning (dto.)
# info (dto.)
# rsync

import sys
import os
import ConfigParser
import datetime
import subprocess

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

# create pid_file


# Compare if last backup is past longer than intervall
# if yes try to backup, but run checks first
#	has the drive been mounted automatically already?
#		if yes, umount, mount again under uuid, success?
#	is drive there?
#	do all directories (src/dest) exist	?
#	if any errors exit and advance due time just 2 days (or configurable)
#
# if no, see if we are 3 days close to it
# if 3 days close to it, give heads up via mail
# if not 3 days close to it, just echo that no backup is needed until...

# delete pidfile
RSYNC_OPTIONS_DEFAULT = "--stats --del -rt"
RSYNC_LOGDIR_DEFAULT = "/var/log/my_backup.log"
DEFAULT_CFG_FILE = "~/.my_backup.cfg"

CHECK_DEV_MOUNTED = "./check_dev_mounted.sh"
UMOUNT_DEV = "./umount_dev.sh"
MOUNT_DEV = "./mount_dev.sh"

cfg_file = None
srcpaths = None
dst_uuid = None
dst_mount = None
dst_path = None
rsync_options = None
rsync_logdir = None
config = None
pidfile = None
retry_days = None
backup_interval_days = None
cfg_file_obj = None
verbose = None

DEBUG = 0
TESTRUN = 0
PROFILE = 0

__version__ = 0.1
__date__ = '2013-02-18'
__updated__ = '2014-08-22'

class BackupNotPossibleError(Exception):
    pass

class ConfigError(Exception):
    pass


def check_srcs_present(srcpaths):
	for path in srcpaths:
		if not os.path.exists(path):
			print("%s does not exist, removing it from the list of sources" % path)
			srcpaths.remove(path)
			continue;
		print("Here is a source path:" + str(path))
		if os.path.isdir(path):
			print("%s is a directoy" % path)
		else:
			print("%s is not a directoy" % path)
			if os.path.isfile(path):
				print("but it is a file")
	return srcpaths

def exit_gracefully():
    global config
    global pidfile
    global retry_days
    global cfg_file
    global cfg_file_obj
    next_action = datetime.date.today()+datetime.timedelta(days=retry_days)
    print("Exiting program, will check again in %s days (%s)" %
            (str(retry_days), str(next_action)))
    config.set('Autogenerated', 'next_action', str(next_action))
    cfg_file_obj = open(str(cfg_file).strip(),'w')
    config.write(cfg_file_obj)
    cfg_file_obj.close()
    #TODO: add this to syslog and to email
    #TODO: Start using the pidfile
    #os.unlink(pidfile)
    sys.exit(3)

def exit_backup_not_possible():
    exit_gracefully()

def exit_config_error():
    exit_gracefully()

def get_dev_for_uuid(uuid):
	uuids = []
	proc = subprocess.Popen(["ls", "-1", "/dev/disk/by-uuid"], stdout=subprocess.PIPE)
	while True:
		line = proc.stdout.readline()
		if line != '':
			uuids.append(line.rstrip())
		else:
			break
        print("Determining block device for UUID %s ... " % str(uuid))

	if uuid[0] in uuids:
		#TODO: more error checking
		proc = subprocess.Popen(["blkid", "-U", str(uuid[0])], stdout=subprocess.PIPE)
		#TODO: more error checking
		dev = proc.stdout.readline()
		print("found %s" % (dev, str(uuid[0])))
	else:
		raise BackupNotPossibleError('found UUID could not be found')
	return  dev


# fiddling with mount points in python is quite tedious, hence we use three helper shell scripts

#returns True if uuid is mounted, False otherwise
def check_dev_mounted(dev):
	proc = subprocess.Popen([CHECK_DEV_MOUNTED, dev], stdout=subprocess.PIPE)
	proc.wait()
	if proc.returncode > 0:
            raise BackupNotPossibleError("%s returned with %s" % CHECK_DEV_MOUNTED, proc.returncode)
	else:
		return True


def umount_dev(dev):
	proc = subprocess.Popen([UMOUNT_DEV, dev], stdout=subprocess.PIPE)
	proc.wait()
        if not proc.returncode:
            raise BackupNotPossibleError("%s returned with %s" % UMOUNT_DEV, proc.returncode)
        else:
            return proc.returncode

def mount_dev(dev, trgt):
	proc = subprocess.Popen([MOUNT_DEV, dev, trgt], stdout=subprocess.PIPE)
	proc.wait()
        if not proc.returncode:
            raise BackupNotPossibleError("%s returned with %s" % MOUNT_DEV, proc.returncode)
        else:
            return proc.returncode

def check_trgt_present(trgt):
	#TODO: assuming we get a UUID, but ultimately parse or customize
	# target type via different command line params
	trgt = check_trgt_UUID(trgt)
	return trgt



def main(argv=None): # IGNORE:C0111
    '''Command line options.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)

    global config
    global retry_days
    global cfg_file_obj
    global cfg_file
    global verbose


    try:
        # Setup argument parser
        parser = ArgumentParser(formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %(default)s]")
        parser.add_argument("-c", "--cfg_file", dest="cfg_file", help="path to config file (default: my_backup.conf")
        parser.add_argument("-u", "--dst_uuid", dest="dst_uuid", help="UUID of the backup disk")
        parser.add_argument("-d", "--dst_path", dest="dst_path", help="Additional path on backup disk")
        parser.add_argument("-m", "--dst_mount", dest="dst_mount", help="mount point for backup disk")
        parser.add_argument("-o", "--rsync_options", dest="rsync_options", help="Options to pass to rsync command")
        parser.add_argument("-l", "--rsync_logdir", dest="rsync_logdir", help="rsync logdir")
        parser.add_argument('-V', '--version', action='version', version=program_version_message)
        parser.add_argument(dest="srcpaths", help="srcpaths to source folders (overrides config file)", nargs='*')

        print("program starts")

        # Process arguments
        args = parser.parse_args()

        verbose = args.verbose
        cfg_file = args.cfg_file
        srcpaths = args.srcpaths
        dst_uuid = args.dst_uuid
	dst_mount = args.dst_mount
        dst_path = args.dst_path
        rsync_options = args.rsync_options
        rsync_logdir = args.rsync_logdir

        pid = str(os.getpid())
        pidfile = "/tmp/mydaemon.pid"

        #if os.path.isfile(pidfile):
        #    print "%s already exists, exiting" % pidfile
        #    sys.exit()
        #else:
        #    file(pidfile, 'w').write(pid)


        if cfg_file:
            config = ConfigParser.ConfigParser()
            config.read(cfg_file)
            print("Config File: %s" % cfg_file)
        else:
            cfg_file = DEFAULT_CFG_FILE
            config = None

        #------------------------ config parsing ----------------------------#
	next_action_string = config.get('Autogenerated', 'next_action')
	backup_interval_days = int(config.get('General', 'backup_interval_days'))
        retry_days = int(config.get('General', 'retry_days'))

        try:
            next_action = datetime.datetime.strptime(next_action_string, '%Y-%m-%d').date()
        except ValueError:
            next_action = datetime.date.today()-datetime.timedelta(days=1)
            config.set('Autogenerated', 'next_action', next_action)

	today = datetime.date.today()

	if today < next_action:
		print("Backup is not due today, will be due on %s" % str(next_action))
                #TODO: what is the adequate return code here?
		sys.exit(0)
	else:
		print("Backup is due")

        if not srcpaths and config:
            srcpaths = config.get('General', 'srcpaths').split()
        if srcpaths:
            print("srcpaths = " + str(srcpaths))
        else:
            print("Source paths are not defined. Pass them on the command line on in the configuration file.")

        if not dst_mount and config:
            dst_mount = config.get('General', 'dst_mount').split()
        if dst_mount:
            print("dst_mount = " + str(dst_mount))
        else:
            print("Destination mount point not defined. Pass it on the command line on in the configuration file.")

        if not dst_uuid and config:
            dst_uuid = config.get('General', 'dst_uuid').split()
        if dst_uuid:
            print("dst_uuid = " + str(dst_uuid))
        else:
            print("Destination UUID not defined. Pass it on the command line on in the configuration file.")

        # Destination path is completely optional
        if not dst_path and config:
            dst_path = config.get('General', 'dst_path').split()
        if dst_path:
            print("dst_path = " + str(dst_uuid))

        if not rsync_options and config:
            rsync_options = config.get('General', 'rsync_options').split()
        if not rsync_options:
            rsync_options = RSYNC_OPTIONS_DEFAULT
        print("rsync_options = " + str(rsync_options))

        if not rsync_logdir and config:
            rsync_logdir = config.get('General', 'rsync_logdir').split()
        if not rsync_logdir:
            rsync_logdir = RSYNC_LOGDIR_DEFAULT
        print("rsync_logdir = " + str(rsync_logdir))

        #------------------------ END OF config parsing ----------------------------#

	srcspaths = check_srcs_present(srcpaths)
	for path in srcpaths:
		print("source path(s):" + str(path))

        try:
            dev = get_dev_for_uuid(dst_uuid)
        except BackupNotPossibleError as e:
            print(e.message)
            exit_backup_not_possible()

        print("Found %s for UUID %s" % (dev, dst_uuid))

        try:
            mounted = check_dev_mounted(dev)
        except BackupNotPossibleError:
            exit_backup_not_possible()

        if mounted:
                print("%s is mounted, umounting it" % (dst_uuid))
                try:
                    umount_dev(dev)
                except BackupNotPossibleError:
                    print("Error unmounting %s" % (dst_uuid))
                    exit_backup_not_possible()
                else:
                        print("Mounting %s again to %s" % (dst_uuid, dst_path))
        else:
                print("%s is not mounted, mounting it to %s" % (dst_uuid, dst_mount))
                print ("call mount %s %s" % (dev, str(dst_mount)))
                try:
                    mount_dev(dev, ''.join(dst_mount))
                except BackupNotPossibleError:
                    exit_backup_not_possible()

	# we made it to this point, disk is properly mounted, now check target path exists
	dst = ''.join((dst_mount + dst_path))
	if not os.path.exists(dst):
		printf("Target path %s on device %s cannot be found" % (dst, dev))
                exit_backup_not_possible()

	# we made it here:
	# src paths all exist, device mounted, target path exists
        print("_________Ready to execute rsync______")




	# if success:
        # run_backup
        # if backup fails
	# next_date_to_act = config.set('Autogenerated', 'next_action', _today+retry_days_)
#if backup successfull
	# next_date_to_act = config.set('Autogenerated', 'next_action', _today+backup_interval_days_)



    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0


if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-v")
    sys.exit(main())

